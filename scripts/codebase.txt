===== File: lib/search.ts =====
Type: .ts
----- Content Start -----
import Fuse from "fuse.js";

interface Product {
  name: string;
  model: string;
  category: string;
  price: number;
  description: string;
  [key: string]: unknown;
}

// Import catalog data using dynamic import
let fullCatalog: Product[] = [];

// Initialize catalog data
async function initializeCatalog() {
  if (fullCatalog.length === 0) {
    try {
      const catalogData = await import("../data/av_products.json");
      fullCatalog = catalogData.default as Product[];
    } catch (error) {
      console.error("Failed to load catalog data:", error);
      fullCatalog = [];
    }
  }
  return fullCatalog;
}

// Configure Fuse.js for comprehensive product search
const fuseOptions = {
  // Search across all relevant fields with weighted importance
  keys: [
    { name: "name", weight: 0.4 }, // Product name is most important
    { name: "model", weight: 0.3 }, // Model numbers are very important
    { name: "description", weight: 0.2 }, // Descriptions help with context
    { name: "category", weight: 0.1 }, // Category for broad searches
    { name: "Product Type", weight: 0.05 }, // Additional product classification
    { name: "Class", weight: 0.05 }, // Product class
    { name: "Sub Class", weight: 0.05 }, // Sub classification
    { name: "Product Code", weight: 0.25 }, // Alternative product codes
    // Include any other searchable fields from your JSON
  ],

  // Search configuration
  threshold: 0.4, // 0.0 = exact match, 1.0 = match anything
  distance: 100, // Maximum allowed distance for fuzzy matching
  includeScore: true, // Include search relevance score
  includeMatches: true, // Show which fields matched
  minMatchCharLength: 2, // Minimum characters to trigger a match
  shouldSort: true, // Sort results by relevance

  // Advanced options for better matching
  ignoreLocation: false, // Consider location of match in string
  ignoreFieldNorm: false, // Field length normalization
  fieldNormWeight: 1, // How much field length affects score
};

// Fuse instance will be created dynamically for each search

// Enhanced search function with multiple strategies
async function searchProducts(
  query: string,
  limit: number = 10
): Promise<Product[]> {
  if (!query || query.trim() === "") {
    return [];
  }

  const catalog = await initializeCatalog();
  if (catalog.length === 0) return [];

  const searchTerm = query.trim();

  // Create Fuse instance with current catalog
  const fuse = new Fuse(catalog, fuseOptions);

  // Strategy 1: Use Fuse.js for intelligent fuzzy search
  const fuseResults = fuse.search(searchTerm, { limit: limit * 2 }); // Get more results to filter

  // Strategy 2: Direct field searches for exact matches (higher priority)
  const exactMatches: Product[] = [];
  const searchLower = searchTerm.toLowerCase();

  catalog.forEach((product) => {
    // Exact model number match (highest priority)
    if (
      product.model?.toLowerCase() === searchLower ||
      product["Product Code"]?.toString().toLowerCase() === searchLower
    ) {
      exactMatches.push(product);
    }
    // Exact name match
    else if (product.name?.toLowerCase() === searchLower) {
      exactMatches.push(product);
    }
  });

  // Strategy 3: Combine and deduplicate results
  const combinedResults = new Map<
    string,
    { product: Product; score: number }
  >();

  // Add exact matches with highest score (0)
  exactMatches.forEach((product) => {
    combinedResults.set(product.model, { product, score: 0 });
  });

  // Add Fuse results if not already included
  fuseResults.forEach((result) => {
    const product = result.item;
    const score = result.score || 1;

    if (!combinedResults.has(product.model)) {
      combinedResults.set(product.model, { product, score });
    }
  });

  // Strategy 4: Sort by relevance and return
  const sortedResults = Array.from(combinedResults.values())
    .sort((a, b) => a.score - b.score) // Lower score = better match
    .slice(0, limit)
    .map((result) => result.product);

  return sortedResults;
}

// Advanced search with category filtering
async function searchProductsByCategory(
  query: string,
  category: string,
  limit: number = 10
): Promise<Product[]> {
  const catalog = await initializeCatalog();
  if (catalog.length === 0) return [];

  const categoryFiltered = catalog.filter(
    (product) =>
      product.category?.toLowerCase().includes(category.toLowerCase()) ||
      product["Product Type"]
        ?.toString()
        .toLowerCase()
        .includes(category.toLowerCase()) ||
      product["Class"]
        ?.toString()
        .toLowerCase()
        .includes(category.toLowerCase())
  );

  const categoryFuse = new Fuse(categoryFiltered, fuseOptions);
  const results = categoryFuse.search(query, { limit });

  return results.map((result) => result.item);
}

// Price range search
async function searchProductsByPriceRange(
  minPrice: number,
  maxPrice: number,
  category?: string
): Promise<Product[]> {
  const catalog = await initializeCatalog();
  if (catalog.length === 0) return [];

  let filtered = catalog.filter((product) => {
    const price =
      typeof product.price === "number"
        ? product.price
        : parseFloat(String(product.price || "0"));
    return price >= minPrice && price <= maxPrice;
  });

  if (category) {
    filtered = filtered.filter((product) =>
      product.category?.toLowerCase().includes(category.toLowerCase())
    );
  }

  return filtered.sort((a, b) => (a.price || 0) - (b.price || 0));
}

// Brand-specific search
async function searchProductsByBrand(
  brandQuery: string,
  limit: number = 20
): Promise<Product[]> {
  const catalog = await initializeCatalog();
  if (catalog.length === 0) return [];

  const brandResults = catalog.filter(
    (product) =>
      product.name?.toLowerCase().includes(brandQuery.toLowerCase()) ||
      product.description?.toLowerCase().includes(brandQuery.toLowerCase())
  );

  return brandResults.slice(0, limit);
}

// Multi-field search for complex queries
async function advancedSearch(params: {
  query?: string;
  category?: string;
  brand?: string;
  minPrice?: number;
  maxPrice?: number;
  limit?: number;
}): Promise<Product[]> {
  const catalog = await initializeCatalog();
  if (catalog.length === 0) return [];

  let results = catalog;

  // Filter by category if specified
  if (params.category) {
    results = results.filter(
      (product) =>
        product.category
          ?.toLowerCase()
          .includes(params.category!.toLowerCase()) ||
        product["Product Type"]
          ?.toString()
          .toLowerCase()
          .includes(params.category!.toLowerCase())
    );
  }

  // Filter by brand if specified
  if (params.brand) {
    results = results.filter(
      (product) =>
        product.name?.toLowerCase().includes(params.brand!.toLowerCase()) ||
        product.description?.toLowerCase().includes(params.brand!.toLowerCase())
    );
  }

  // Filter by price range if specified
  if (params.minPrice !== undefined || params.maxPrice !== undefined) {
    results = results.filter((product) => {
      const price =
        typeof product.price === "number"
          ? product.price
          : parseFloat(String(product.price || "0"));
      if (params.minPrice !== undefined && price < params.minPrice)
        return false;
      if (params.maxPrice !== undefined && price > params.maxPrice)
        return false;
      return true;
    });
  }

  // Apply text search if query specified
  if (params.query) {
    const filteredFuse = new Fuse(results, fuseOptions);
    const searchResults = filteredFuse.search(params.query, {
      limit: params.limit || 10,
    });
    return searchResults.map((result) => result.item);
  }

  return results.slice(0, params.limit || 10);
}

// Export all search functions
export {
  searchProducts,
  searchProductsByCategory,
  searchProductsByPriceRange,
  searchProductsByBrand,
  advancedSearch,
};

----- Content End -----

===== File: lib/ai.ts =====
Type: .ts
----- Content Start -----
import OpenAI from "openai";
import {
  searchProducts,
  searchProductsByCategory,
  searchProductsByPriceRange,
  searchProductsByBrand,
  advancedSearch,
} from "./search";

interface Product {
  name: string;
  model: string;
  category: string;
  price: number;
  description: string;
  [key: string]: unknown;
}

interface SearchResult {
  products: Product[];
  searchQueries: string[];
  totalFound: number;
}

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export async function searchAgentGatherProducts(
  emailBody: string,
  subject: string
): Promise<SearchResult> {
  const allFoundProducts = new Map<string, Product>();
  const searchQueries: string[] = [];
  const searchStrategies: string[] = [];
  let iterations = 0;
  const maxIterations = 12;

  try {
    while (iterations < maxIterations) {
      iterations++;

      const response = await openai.chat.completions.create({
        model: "gpt-4.1-mini-2025-04-14",
        response_format: { type: "json_object" },
        messages: [
          {
            role: "system",
            content: `You are an advanced product search agent with a critical mission: gather as much relevant product data as possible to enable a smarter LLM to respond to customer emails with maximum accuracy and completeness.

Your primary goal is to collect comprehensive, relevant product information that will allow the final AI response to be highly accurate, detailed, and helpful.

Available search strategies:
1. "basic" - General text search across all product fields
2. "category" - Search within specific product categories  
3. "brand" - Brand-specific search
4. "price_range" - Search by price range
5. "advanced" - Multi-parameter search with filters
6. "complementary" - Find accessories/items that complement already found products

Your task: Choose ONE strategy and provide the parameters for that search.

Consider:
- Exact model numbers, brands, categories mentioned
- Use cases (education, corporate, installation, etc.)
- Price constraints or budget mentions
- Accessories that complement main products found
- Product relationships (projector â†’ cases, mounts, cables)
- Alternative products that might meet their needs
- Related products that could enhance their setup
- Products mentioned in similar contexts

Current iteration: ${iterations}/${maxIterations}
Products found so far: ${allFoundProducts.size}
${
  searchQueries.length > 0
    ? `Previous searches: ${searchQueries.join(", ")}`
    : ""
}
${
  searchStrategies.length > 0
    ? `Strategies used: ${searchStrategies.join(", ")}`
    : ""
}

CRITICAL OBJECTIVES:
- Gather comprehensive product data to enable highly accurate AI responses
- Find ALL relevant products, not just the most obvious ones
- Consider edge cases, alternatives, and complementary items
- Think about what information the final AI will need to provide a complete response
- Don't repeat the same search parameters
- Consider what products we already found and what additional data would be valuable
- Prioritize breadth and completeness over speed - accuracy depends on having all relevant data

Respond with JSON based on chosen strategy:

For "basic" strategy:
{
  "strategy": "basic",
  "searchQuery": "search terms",
  "reasoning": "why this query",
  "isDone": boolean
}

For "category" strategy:
{
  "strategy": "category", 
  "searchQuery": "search terms",
  "category": "category name",
  "reasoning": "why this category search",
  "isDone": boolean
}

For "brand" strategy:
{
  "strategy": "brand",
  "brandQuery": "brand name", 
  "reasoning": "why this brand",
  "isDone": boolean
}

For "price_range" strategy:
{
  "strategy": "price_range",
  "minPrice": number,
  "maxPrice": number,
  "category": "optional category filter",
  "reasoning": "why this price range",
  "isDone": boolean
}

For "advanced" strategy:
{
  "strategy": "advanced",
  "query": "optional text query",
  "category": "optional category",
  "brand": "optional brand",
  "minPrice": "optional min price",
  "maxPrice": "optional max price",
  "reasoning": "why these specific filters",
  "isDone": boolean
}

For "complementary" strategy:
{
  "strategy": "complementary",
  "searchQuery": "accessories or complementary items",
  "reasoning": "why these complement existing products",
  "isDone": boolean
}`,
          },
          {
            role: "user",
            content: `Customer Email Subject: ${subject}\n\nCustomer Email:\n${emailBody}

${
  allFoundProducts.size > 0
    ? `\nProducts already found:\n${Array.from(allFoundProducts.values())
        .slice(0, 5)
        .map((p) => `- ${p.name} (${p.model})`)
        .join("\n")}${
        allFoundProducts.size > 5
          ? `\n... and ${allFoundProducts.size - 5} more`
          : ""
      }`
    : ""
}`,
          },
        ],
      });

      const content = response.choices[0].message.content;
      if (!content) break;

      const result = JSON.parse(content);
      let products: Product[] = [];
      let searchDescription = "";

      // Execute search based on chosen strategy
      switch (result.strategy) {
        case "basic":
          if (
            result.searchQuery &&
            !searchQueries.includes(result.searchQuery)
          ) {
            searchQueries.push(result.searchQuery);
            searchStrategies.push("basic");
            products = await searchProducts(result.searchQuery, 12);
            searchDescription = `Basic search: "${result.searchQuery}"`;
          }
          break;

        case "category":
          const categoryQuery = `${result.searchQuery} in ${result.category}`;
          if (!searchQueries.includes(categoryQuery)) {
            searchQueries.push(categoryQuery);
            searchStrategies.push("category");
            products = await searchProductsByCategory(
              result.searchQuery,
              result.category,
              12
            );
            searchDescription = `Category search: "${result.searchQuery}" in ${result.category}`;
          }
          break;

        case "brand":
          if (
            result.brandQuery &&
            !searchQueries.includes(`brand:${result.brandQuery}`)
          ) {
            searchQueries.push(`brand:${result.brandQuery}`);
            searchStrategies.push("brand");
            products = await searchProductsByBrand(result.brandQuery, 15);
            searchDescription = `Brand search: ${result.brandQuery}`;
          }
          break;

        case "price_range":
          const priceQuery = `price:${result.minPrice}-${result.maxPrice}${
            result.category ? ` category:${result.category}` : ""
          }`;
          if (!searchQueries.includes(priceQuery)) {
            searchQueries.push(priceQuery);
            searchStrategies.push("price_range");
            products = await searchProductsByPriceRange(
              result.minPrice,
              result.maxPrice,
              result.category
            );
            searchDescription = `Price range: $${result.minPrice}-$${
              result.maxPrice
            }${result.category ? ` in ${result.category}` : ""}`;
          }
          break;

        case "advanced":
          const advancedQuery = `advanced:${JSON.stringify({
            query: result.query,
            category: result.category,
            brand: result.brand,
            minPrice: result.minPrice,
            maxPrice: result.maxPrice,
          })}`;
          if (!searchQueries.includes(advancedQuery)) {
            searchQueries.push(advancedQuery);
            searchStrategies.push("advanced");
            products = await advancedSearch({
              query: result.query,
              category: result.category,
              brand: result.brand,
              minPrice: result.minPrice,
              maxPrice: result.maxPrice,
              limit: 12,
            });
            searchDescription = `Advanced search with multiple filters`;
          }
          break;

        case "complementary":
          if (
            result.searchQuery &&
            !searchQueries.includes(`comp:${result.searchQuery}`)
          ) {
            searchQueries.push(`comp:${result.searchQuery}`);
            searchStrategies.push("complementary");
            products = await searchProducts(result.searchQuery, 10);
            searchDescription = `Complementary search: "${result.searchQuery}"`;
          }
          break;

        default:
          console.log(`Unknown strategy: ${result.strategy}`);
          break;
      }

      // Add found products to our collection (Map prevents duplicates by model)
      if (products.length > 0) {
        console.log(`${searchDescription} found ${products.length} products`);
        products.forEach((product) => {
          allFoundProducts.set(product.model, product);
        });
      }

      // Enhanced stopping criteria - prioritize comprehensive data gathering
      const shouldStop =
        result.isDone ||
        allFoundProducts.size >= 40 || // Increased from 25 to allow more comprehensive data
        (iterations >= 8 && allFoundProducts.size >= 20) || // Increased iterations and threshold
        (iterations >= 6 && products.length === 0); // Stop if no new products found after 6 iterations

      if (shouldStop) {
        console.log(
          `Search agent stopping: isDone=${result.isDone}, products=${allFoundProducts.size}, iterations=${iterations}`
        );
        break;
      }
    }
  } catch (error) {
    console.error("Search agent error:", error);
  }

  console.log(
    `Search agent completed: ${
      allFoundProducts.size
    } unique products found using strategies: ${[
      ...new Set(searchStrategies),
    ].join(", ")} - Comprehensive data gathered for accurate AI response`
  );

  return {
    products: Array.from(allFoundProducts.values()),
    searchQueries,
    totalFound: allFoundProducts.size,
  };
}

// Modified: Now uses search agent results
export async function generateEmailResponse(
  emailBody: string,
  subject: string
): Promise<string | null> {
  try {
    // First, let search agent gather relevant products
    const searchResult = await searchAgentGatherProducts(emailBody, subject);

    console.log(
      `Search agent found ${
        searchResult.totalFound
      } products with queries: ${searchResult.searchQueries.join(", ")}`
    );

    // Now use o3 (or your preferred smart model) for final response
    const response = await openai.chat.completions.create({
      model: "o3-2025-04-16", // Using o3 for the smart response
      messages: [
        {
          role: "system",
          content: `You are an expert AV equipment sales assistant. You have been provided with a curated selection of relevant products from our catalog based on the customer's inquiry.

Product Catalog (Pre-filtered and relevant):
${JSON.stringify(searchResult.products, null, 2)}

Respond to the customer's inquiry in a helpful and professional email. Sign emails as "Best regards, The New York Marketing Team"

Search context: Found ${
            searchResult.totalFound
          } relevant products using queries: ${searchResult.searchQueries.join(
            ", "
          )}`,
        },
        {
          role: "user",
          content: `Customer Email Subject: ${subject}\n\nCustomer Email:\n${emailBody}`,
        },
      ],
    });

    return response.choices[0].message.content;
  } catch (error) {
    console.error("AI response generation error:", error);
    return null;
  }
}

// Modified: Now uses search agent for upsells
export async function generateUpsellResponse(
  emailBody: string,
  subject: string
): Promise<string | null> {
  try {
    // Search for products related to their purchase + complementary items
    const searchResult = await searchAgentGatherProducts(emailBody, subject);

    console.log(`Upsell search found ${searchResult.totalFound} products`);

    const response = await openai.chat.completions.create({
      model: "o3-2025-04-16",
      messages: [
        {
          role: "system",
          content: `You are an expert AV equipment sales assistant specializing in complementary product recommendations.

Relevant Products (Pre-filtered based on their purchase):
${JSON.stringify(searchResult.products, null, 2)}

Guidelines:
- Analyze their purchase and suggest 2-3 genuinely complementary products
- Focus on items that complete their setup or solve common problems
- Include brief explanation of why each item is recommended
- Be helpful, not pushy - focus on value
- Include pricing and model numbers
- Sign emails as "Best regards, The New York Marketing Team"`,
        },
        {
          role: "user",
          content: `Purchase Order Subject: ${subject}\n\nPurchase Order:\n${emailBody}`,
        },
      ],
    });

    return response.choices[0].message.content;
  } catch (error) {
    console.error("AI upsell generation error:", error);
    return null;
  }
}

export async function classifyEmailType(
  emailBody: string,
  subject: string
): Promise<"product_inquiry" | "purchase_order" | "other"> {
  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4.1-mini-2025-04-14",
      response_format: { type: "json_object" },
      messages: [
        {
          role: "system",
          content: `Classify the email into one of three categories. ONLY respond to emails that are specifically about AV (Audio/Video) equipment sales, products, or services.

1. "product_inquiry" - Customer is asking about AV equipment products, pricing, availability, quotes, specifications, recommendations, installation, or technical support for AV equipment. Must be specifically about AV products/services.

2. "purchase_order" - Customer is placing an order for AV equipment, includes PO numbers, "please ship", "we'll take", quantity commitments, delivery requests, final purchase decisions for AV products.

3. "other" - ANY email that is NOT specifically about AV equipment, including: thank you messages, shipping status, complaints, general business questions, personal emails, spam, emails about other industries/products, or anything unrelated to AV sales.

IMPORTANT: If the email is about anything other than AV equipment sales, products, or services, classify as "other". Do not respond to non-AV related emails.

Respond with JSON: {"emailType": "product_inquiry" | "purchase_order" | "other"}`,
        },
        {
          role: "user",
          content: `Email Subject: ${subject}\n\nEmail Body:\n${emailBody}`,
        },
      ],
    });

    const content = response.choices[0].message.content;
    if (!content) {
      console.error("No content in AI response");
      return "other";
    }

    const result = JSON.parse(content);
    const emailType = result.emailType;

    if (
      emailType === "product_inquiry" ||
      emailType === "purchase_order" ||
      emailType === "other"
    ) {
      return emailType;
    }

    console.error("Invalid email type returned:", emailType);
    return "other";
  } catch (error) {
    console.error("AI email classification error:", error);
    return "other";
  }
}

----- Content End -----

===== File: lib/db.ts =====
Type: .ts
----- Content Start -----
import { Pool } from "pg";

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl:
    process.env.NODE_ENV === "production"
      ? { rejectUnauthorized: false }
      : false,
});

// Test connection on startup
pool.on("connect", () => {
  console.log("Connected to PostgreSQL database");
});

pool.on("error", (err) => {
  console.error("Database connection error:", err);
});

// Database operation functions
export async function getUserWithAutomation(email: string) {
  const client = await pool.connect();
  try {
    const result = await client.query(
      "SELECT * FROM users WHERE email = $1 AND automation_enabled = true",
      [email]
    );
    return result.rows[0] || null;
  } finally {
    client.release();
  }
}

export async function isEmailProcessed(emailId: string) {
  const client = await pool.connect();
  try {
    const result = await client.query(
      "SELECT id FROM processed_emails WHERE email_id = $1",
      [emailId]
    );
    return result.rows.length > 0;
  } finally {
    client.release();
  }
}

export async function markEmailAsProcessed(emailId: string, userId: number) {
  const client = await pool.connect();
  try {
    await client.query(
      "INSERT INTO processed_emails (email_id, user_id) VALUES ($1, $2)",
      [emailId, userId]
    );
  } finally {
    client.release();
  }
}

export async function updateUserAutomation(email: string, enabled: boolean) {
  const client = await pool.connect();
  try {
    await client.query(
      "UPDATE users SET automation_enabled = $1 WHERE email = $2",
      [enabled, email]
    );
  } finally {
    client.release();
  }
}

export async function getUserByGoogleId(googleId: string) {
  const client = await pool.connect();
  try {
    const result = await client.query(
      "SELECT * FROM users WHERE google_id = $1",
      [googleId]
    );
    return result.rows[0] || null;
  } finally {
    client.release();
  }
}

export async function createUser(
  email: string,
  googleId: string,
  accessToken: string,
  refreshToken: string
) {
  const client = await pool.connect();
  try {
    await client.query(
      "INSERT INTO users (email, google_id, access_token, refresh_token) VALUES ($1, $2, $3, $4)",
      [email, googleId, accessToken, refreshToken]
    );
  } finally {
    client.release();
  }
}

export async function updateUserTokens(
  googleId: string,
  accessToken: string,
  refreshToken: string
) {
  const client = await pool.connect();
  try {
    await client.query(
      "UPDATE users SET access_token = $1, refresh_token = $2 WHERE google_id = $3",
      [accessToken, refreshToken, googleId]
    );
  } finally {
    client.release();
  }
}

export async function getUserByEmail(email: string) {
  const client = await pool.connect();
  try {
    const result = await client.query(
      "SELECT id, automation_enabled FROM users WHERE email = $1",
      [email]
    );
    return result.rows[0] || null;
  } finally {
    client.release();
  }
}

export async function setupDatabase() {
  const client = await pool.connect();
  try {
    // Create users table
    await client.query(`
      CREATE TABLE IF NOT EXISTS users (
        id SERIAL PRIMARY KEY,
        email VARCHAR(255) UNIQUE NOT NULL,
        google_id VARCHAR(255) UNIQUE NOT NULL,
        access_token TEXT,
        refresh_token TEXT,
        automation_enabled BOOLEAN DEFAULT false,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Create processed emails table
    await client.query(`
      CREATE TABLE IF NOT EXISTS processed_emails (
        id SERIAL PRIMARY KEY,
        email_id VARCHAR(255) UNIQUE NOT NULL,
        user_id INTEGER REFERENCES users(id),
        processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
  } finally {
    client.release();
  }
}

export async function getUserTokens(email: string) {
  try {
    const client = await pool.connect();
    const result = await client.query(
      "SELECT access_token, refresh_token FROM users WHERE email = $1",
      [email]
    );
    client.release();

    return result.rows.length > 0 ? result.rows[0] : null;
  } catch (error) {
    console.error("Error getting user tokens:", error);
    return null;
  }
}

export default pool;

----- Content End -----

===== File: lib/auth.ts =====
Type: .ts
----- Content Start -----
import GoogleProvider from "next-auth/providers/google";
import {
  getUserByGoogleId,
  createUser,
  updateUserTokens,
  getUserByEmail,
} from "@/lib/db";
import { NextAuthOptions, DefaultSession } from "next-auth";

declare module "next-auth" {
  interface Session {
    user: {
      id?: string;
      automationEnabled?: boolean;
    } & DefaultSession["user"];
  }
}

export const authOptions: NextAuthOptions = {
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
      authorization: {
        params: {
          scope:
            "openid email profile https://www.googleapis.com/auth/gmail.readonly https://www.googleapis.com/auth/gmail.send https://www.googleapis.com/auth/gmail.settings.basic",
        },
      },
    }),
  ],
  callbacks: {
    async signIn({ user, account }) {
      if (account?.provider === "google") {
        try {
          // Check if user exists
          const existingUser = await getUserByGoogleId(
            account.providerAccountId
          );

          if (!existingUser) {
            // Create new user
            await createUser(
              user.email!,
              account.providerAccountId,
              account.access_token!,
              account.refresh_token!
            );
          } else {
            // Update existing user tokens
            await updateUserTokens(
              account.providerAccountId,
              account.access_token!,
              account.refresh_token!
            );
          }

          return true;
        } catch (error) {
          console.error("Database error during sign in:", error);
          return false;
        }
      }
      return true;
    },
    async session({ session }) {
      // Add user database info to session
      try {
        const user = await getUserByEmail(session.user?.email || "");

        if (user && session.user) {
          session.user.id = user.id;
          session.user.automationEnabled = user.automation_enabled;
        }
      } catch (error) {
        console.error("Session callback error:", error);
      }

      return session;
    },
  },
};

----- Content End -----

===== File: app/layout.tsx =====
Type: .tsx
----- Content Start -----
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import SessionWrapper from "@/components/SessionWrapper";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "AV Automation",
  description: "AV Automation",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <SessionWrapper>{children}</SessionWrapper>
      </body>
    </html>
  );
}

----- Content End -----

===== File: app/page.tsx =====
Type: .tsx
----- Content Start -----
"use client";

import { useSession, signIn, signOut } from "next-auth/react";
import { useState, useEffect } from "react";

export default function HomePage() {
  const { data: session, status, update } = useSession();
  const [automationEnabled, setAutomationEnabled] = useState(false);
  const [loading, setLoading] = useState(false);

  // Load automation status when session loads
  useEffect(() => {
    if (session?.user?.automationEnabled !== undefined) {
      setAutomationEnabled(session.user.automationEnabled);
    }
  }, [session]);

  const toggleAutomation = async () => {
    setLoading(true);
    try {
      const response = await fetch("/api/toggle-automation", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ enabled: !automationEnabled }),
      });

      if (response.ok) {
        setAutomationEnabled(!automationEnabled);
        // Update the session to reflect new status
        await update();
      } else {
        console.error("Failed to toggle automation");
      }
    } catch (error) {
      console.error("Error toggling automation:", error);
    }
    setLoading(false);
  };

  if (status === "loading") {
    return <div className="p-8">Loading...</div>;
  }

  if (!session) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="max-w-md w-full space-y-8">
          <div>
            <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
              AV Equipment Automation
            </h2>
            <p className="mt-2 text-center text-sm text-gray-600">
              Sign in with Google to manage your email automation
            </p>
          </div>
          <button
            onClick={() => signIn("google")}
            className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          >
            Sign in with Google
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50">
      <div className="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
        <div className="px-4 py-6 sm:px-0">
          <div className="border-4 border-dashed border-gray-200 rounded-lg p-8">
            <div className="flex justify-between items-center mb-8">
              <div>
                <h1 className="text-2xl font-bold text-gray-900">
                  AV Equipment Email Automation
                </h1>
                <p className="text-gray-600">Welcome, {session.user.email}</p>
              </div>
              <button
                onClick={() => signOut()}
                className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded"
              >
                Sign Out
              </button>
            </div>

            <div className="bg-white shadow rounded-lg p-6">
              <div className="flex items-center justify-between">
                <div>
                  <h2 className="text-lg font-medium text-gray-900">
                    Email Automation
                  </h2>
                  <p className="text-sm text-gray-500">
                    {automationEnabled
                      ? "Automation is active - AI will respond to incoming emails"
                      : "Automation is disabled - emails will not be processed"}
                  </p>
                </div>
                <div className="flex items-center">
                  <button
                    onClick={toggleAutomation}
                    disabled={loading}
                    className={`${
                      automationEnabled ? "bg-green-600" : "bg-gray-200"
                    } relative inline-flex flex-shrink-0 h-6 w-11 border-2 border-transparent rounded-full cursor-pointer transition-colors ease-in-out duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 ${
                      loading ? "opacity-50 cursor-not-allowed" : ""
                    }`}
                  >
                    <span
                      className={`${
                        automationEnabled ? "translate-x-5" : "translate-x-0"
                      } pointer-events-none inline-block h-5 w-5 rounded-full bg-white shadow transform ring-0 transition ease-in-out duration-200`}
                    />
                  </button>
                  <span className="ml-3 text-sm font-medium text-gray-900">
                    {automationEnabled ? "ON" : "OFF"}
                  </span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

----- Content End -----

===== File: app/globals.css =====
Type: .css
----- Content Start -----
@import "tailwindcss";

----- Content End -----

===== File: app/api/auth/[...nextauth]/route.ts =====
Type: .ts
----- Content Start -----
import NextAuth from "next-auth";
import { authOptions } from "@/lib/auth";

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };

----- Content End -----

===== File: app/api/setup-db/route.ts =====
Type: .ts
----- Content Start -----
import { setupDatabase } from "@/lib/db";
import {
  searchProducts,
  searchProductsByBrand,
  searchProductsByCategory,
  searchProductsByPriceRange,
  advancedSearch,
} from "@/lib/search";
import { NextResponse } from "next/server";

export async function POST() {
  try {
    await setupDatabase();

    // Test search functionality
    console.log("Testing search functionality...");

    // Test 1: Basic search for EPSON products
    const epsonResults = await searchProducts("EPSON", 3);
    console.log(`Found ${epsonResults.length} EPSON products`);

    // Test 2: Brand search for EPSON
    const brandResults = await searchProductsByBrand("EPSON", 3);
    console.log(`Found ${brandResults.length} EPSON brand products`);

    // Test 3: Category search for projector accessories
    const categoryResults = await searchProductsByCategory(
      "projector",
      "ACCESSORIES",
      3
    );
    console.log(`Found ${categoryResults.length} projector accessories`);

    // Test 4: Price range search for accessories under $100
    const priceResults = await searchProductsByPriceRange(
      0,
      100,
      "ACCESSORIES"
    );
    console.log(`Found ${priceResults.length} accessories under $100`);

    // Test 5: Advanced search for cases in accessories $20-$100
    const advancedResults = await advancedSearch({
      query: "case",
      category: "ACCESSORIES",
      minPrice: 20,
      maxPrice: 100,
      limit: 3,
    });
    console.log(
      `Found ${advancedResults.length} cases in accessories $20-$100`
    );

    return NextResponse.json({
      success: true,
      message: "Database tables created successfully",
      searchTest: {
        basicSearch: {
          query: "EPSON",
          results: epsonResults.length,
          sampleProducts: epsonResults.slice(0, 2).map((p) => ({
            name: p.name,
            model: p.model,
            price: p.price,
          })),
        },
        brandSearch: {
          query: "EPSON",
          results: brandResults.length,
          sampleProducts: brandResults.slice(0, 2).map((p) => ({
            name: p.name,
            model: p.model,
            price: p.price,
          })),
        },
        categorySearch: {
          query: "projector",
          category: "ACCESSORIES",
          results: categoryResults.length,
          sampleProducts: categoryResults.slice(0, 2).map((p) => ({
            name: p.name,
            model: p.model,
            price: p.price,
          })),
        },
        priceRangeSearch: {
          minPrice: 0,
          maxPrice: 100,
          category: "ACCESSORIES",
          results: priceResults.length,
          sampleProducts: priceResults.slice(0, 2).map((p) => ({
            name: p.name,
            model: p.model,
            price: p.price,
          })),
        },
        advancedSearch: {
          query: "case",
          category: "ACCESSORIES",
          minPrice: 20,
          maxPrice: 100,
          results: advancedResults.length,
          sampleProducts: advancedResults.slice(0, 2).map((p) => ({
            name: p.name,
            model: p.model,
            price: p.price,
          })),
        },
      },
    });
  } catch (error) {
    console.error("Database setup error:", error);
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    );
  }
}

----- Content End -----

===== File: app/api/gmail-webhook/route.ts =====
Type: .ts
----- Content Start -----
import { NextResponse } from "next/server";
import {
  getUserWithAutomation,
  isEmailProcessed,
  markEmailAsProcessed,
} from "@/lib/db";
import {
  generateEmailResponse,
  classifyEmailType,
  generateUpsellResponse,
} from "@/lib/ai";
import { google } from "googleapis";
import { gmail_v1 } from "googleapis/build/src/apis/gmail/v1";

// Type definitions
interface User {
  id: number;
  email: string;
  access_token: string;
  refresh_token: string;
  automation_enabled: boolean;
}

type EmailData = gmail_v1.Schema$Message;

export async function POST(request: Request) {
  try {
    // Parse Pub/Sub message format
    const body = await request.json();
    console.log("Pub/Sub webhook received:", body);

    // Pub/Sub sends messages in this format:
    // { message: { data: base64EncodedData, attributes: {}, messageId: "", publishTime: "" } }
    if (body.message && body.message.data) {
      // Decode the Pub/Sub message data
      const pubsubData = JSON.parse(
        Buffer.from(body.message.data, "base64").toString()
      );

      console.log("Decoded Pub/Sub data:", pubsubData);

      // Gmail Pub/Sub notification contains: { emailAddress, historyId }
      const { emailAddress } = pubsubData;

      if (!emailAddress) {
        console.log("No emailAddress in Pub/Sub message");
        return NextResponse.json({ message: "No email address provided" });
      }

      // Get user from database
      const user = await getUserWithAutomation(emailAddress);

      if (!user) {
        console.log(
          `User not found or automation disabled for: ${emailAddress}`
        );
        return NextResponse.json({
          message: "User not found or automation disabled",
        });
      }

      console.log(`Processing emails for user: ${emailAddress}`);

      // Set up Gmail API
      const oauth2Client = new google.auth.OAuth2(
        process.env.GOOGLE_CLIENT_ID,
        process.env.GOOGLE_CLIENT_SECRET
      );

      oauth2Client.setCredentials({
        access_token: user.access_token,
        refresh_token: user.refresh_token,
      });

      const gmail = google.gmail({ version: "v1", auth: oauth2Client });

      // Get recent unread messages
      const response = await gmail.users.messages.list({
        userId: "me",
        maxResults: 10,
        q: "is:unread",
      });

      console.log(
        `Found ${response.data.messages?.length || 0} unread messages`
      );

      if (response.data.messages) {
        for (const message of response.data.messages) {
          if (!message.id) continue;

          // Check if we've already processed this email
          const isProcessed = await isEmailProcessed(message.id);

          if (!isProcessed) {
            console.log(`Processing new email: ${message.id}`);
            // Process this new email
            await processEmail(gmail, message.id, user);
          } else {
            console.log(`Email already processed: ${message.id}`);
          }
        }
      }
    }

    // Always return 200 OK to acknowledge the Pub/Sub message
    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Pub/Sub webhook error:", error);
    // Still return 200 to avoid Pub/Sub retries on permanent failures
    return NextResponse.json(
      {
        error:
          error instanceof Error ? error.message : "Webhook processing failed",
      },
      { status: 200 }
    );
  }
}

async function processEmail(
  gmail: gmail_v1.Gmail,
  messageId: string,
  user: User
) {
  try {
    // Get email content
    const email = await gmail.users.messages.get({
      userId: "me",
      id: messageId,
      format: "full",
    });

    const emailBody = extractEmailBody(email.data);
    const subject = getEmailSubject(email.data);
    const fromEmail = getFromEmail(email.data);

    console.log("Processing email:", subject);
    console.log("From:", fromEmail);
    console.log("Email body preview:", emailBody.substring(0, 200) + "...");

    // Skip emails from the user themselves (avoid loops)
    if (fromEmail && fromEmail.includes(user.email)) {
      console.log("Skipping email from self");
      await markEmailAsProcessed(messageId, user.id);
      return;
    }

    // Classify email type using single AI call
    const emailType = await classifyEmailType(emailBody, subject);

    if (emailType === "purchase_order") {
      console.log(
        "Email identified as purchase order by AI - generating upsell"
      );

      const upsellResponse = await generateUpsellResponse(emailBody, subject);

      if (upsellResponse) {
        await sendReply(gmail, email.data, upsellResponse);
        await markEmailAsProcessed(messageId, user.id);
        console.log("Purchase order processed and upsell sent successfully");
      }
    } else if (emailType === "product_inquiry") {
      console.log("Email identified as product inquiry by AI");

      const aiResponse = await generateEmailResponse(emailBody, subject);

      if (aiResponse) {
        await sendReply(gmail, email.data, aiResponse);
        await markEmailAsProcessed(messageId, user.id);
        console.log("Email processed and reply sent successfully");
      }
    } else {
      console.log(
        "Email not identified as product inquiry or purchase order, skipping"
      );
      await markEmailAsProcessed(messageId, user.id);
    }
  } catch (error) {
    console.error("Error processing email:", error);
    // Mark as processed even on error to avoid infinite retries
    await markEmailAsProcessed(messageId, user.id);
  }
}

function extractEmailBody(emailData: EmailData): string {
  // Extract text from email body
  let body = "";

  if (emailData.payload?.body?.data) {
    body = Buffer.from(emailData.payload.body.data, "base64").toString();
  } else if (emailData.payload?.parts) {
    for (const part of emailData.payload.parts) {
      if (part.mimeType === "text/plain" && part.body?.data) {
        body += Buffer.from(part.body.data, "base64").toString();
      }
    }
  }

  return body;
}

function getEmailSubject(emailData: EmailData): string {
  const subjectHeader = emailData.payload?.headers?.find(
    (h) => h.name === "Subject"
  );
  return subjectHeader?.value || "";
}

function getFromEmail(emailData: EmailData): string {
  const fromHeader = emailData.payload?.headers?.find((h) => h.name === "From");
  return fromHeader?.value || "";
}

async function sendReply(
  gmail: gmail_v1.Gmail,
  originalEmail: EmailData,
  replyContent: string
): Promise<void> {
  try {
    const subject = getEmailSubject(originalEmail);
    const fromHeader = originalEmail.payload?.headers?.find(
      (h) => h.name === "From"
    );
    if (!fromHeader) {
      throw new Error("From header not found in email");
    }
    const toEmail = fromHeader.value;

    const replySubject = subject.startsWith("Re:") ? subject : `Re: ${subject}`;

    const emailLines = [
      `To: ${toEmail}`,
      `Subject: ${replySubject}`,
      `In-Reply-To: ${originalEmail.id}`,
      `References: ${originalEmail.id}`,
      "",
      replyContent,
    ];

    const email = emailLines.join("\n");
    const encodedEmail = Buffer.from(email).toString("base64url");

    await gmail.users.messages.send({
      userId: "me",
      requestBody: {
        raw: encodedEmail,
      },
    });

    console.log("Reply sent successfully");
  } catch (error) {
    console.error("Error sending reply:", error);
    throw error;
  }
}

----- Content End -----

===== File: app/api/toggle-automation/route.ts =====
Type: .ts
----- Content Start -----
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { updateUserAutomation, getUserTokens } from "@/lib/db";
import { google } from "googleapis";
import { NextResponse } from "next/server";

export async function POST(request: Request) {
  try {
    const session = await getServerSession(authOptions);

    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { enabled } = await request.json();

    // Update automation status in database
    await updateUserAutomation(session.user.email!, enabled);

    // Handle Gmail watch based on automation status
    if (enabled) {
      // Enable Gmail watch
      const watchResult = await enableGmailWatch(session.user.email!);
      if (!watchResult.success) {
        console.error("Failed to enable Gmail watch:", watchResult.error);
        // Don't fail the whole request, just log the error
      }
    } else {
      // Disable Gmail watch
      const stopResult = await disableGmailWatch(session.user.email!);
      if (!stopResult.success) {
        console.error("Failed to disable Gmail watch:", stopResult.error);
        // Don't fail the whole request, just log the error
      }
    }

    return NextResponse.json({ success: true, enabled });
  } catch (error) {
    console.error("Toggle automation error:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

async function enableGmailWatch(email: string) {
  try {
    // Get user tokens
    const tokens = await getUserTokens(email);
    if (!tokens) {
      return { success: false, error: "User tokens not found" };
    }

    // Set up Gmail API
    const oauth2Client = new google.auth.OAuth2(
      process.env.GOOGLE_CLIENT_ID,
      process.env.GOOGLE_CLIENT_SECRET
    );

    oauth2Client.setCredentials({
      access_token: tokens.access_token,
      refresh_token: tokens.refresh_token,
    });

    const gmail = google.gmail({ version: "v1", auth: oauth2Client });

    // Enable Gmail watch
    const response = await gmail.users.watch({
      userId: "me",
      requestBody: {
        topicName: "projects/finao-468122/topics/gmail-notifications",
        labelIds: ["INBOX"],
      },
    });

    console.log("Gmail watch enabled for:", email, response.data);
    return { success: true, data: response.data };
  } catch (error) {
    console.error("Error enabling Gmail watch:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error",
    };
  }
}

async function disableGmailWatch(email: string) {
  try {
    // Get user tokens
    const tokens = await getUserTokens(email);
    if (!tokens) {
      return { success: false, error: "User tokens not found" };
    }

    // Set up Gmail API
    const oauth2Client = new google.auth.OAuth2(
      process.env.GOOGLE_CLIENT_ID,
      process.env.GOOGLE_CLIENT_SECRET
    );

    oauth2Client.setCredentials({
      access_token: tokens.access_token,
      refresh_token: tokens.refresh_token,
    });

    const gmail = google.gmail({ version: "v1", auth: oauth2Client });

    // Stop Gmail watch
    await gmail.users.stop({
      userId: "me",
    });

    console.log("Gmail watch disabled for:", email);
    return { success: true };
  } catch (error) {
    console.error("Error disabling Gmail watch:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error",
    };
  }
}

----- Content End -----

===== File: components/SessionWrapper.tsx =====
Type: .tsx
----- Content Start -----
"use client";

import { SessionProvider } from "next-auth/react";
import { ReactNode } from "react";

export default function SessionWrapper({ children }: { children: ReactNode }) {
  return <SessionProvider>{children}</SessionProvider>;
}

----- Content End -----

